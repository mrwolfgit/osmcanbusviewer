<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CAN Log Viewer — single file</title>
  <!-- Tailwind (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React 18 + ReactDOM (UMD) -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- Recharts (UMD) -->
  <script crossorigin src="https://unpkg.com/recharts/umd/Recharts.js"></script>
  <!-- Babel for JSX in-browser -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-slate-50">
  <div id="root" class="p-6 max-w-6xl mx-auto"></div>

  <script type="text/babel">
    const { useState, useMemo } = React;
    const {
      LineChart, Line, XAxis, YAxis, Tooltip, CartesianGrid, ResponsiveContainer
    } = Recharts;

    function CANLogViewer() {
      const [frames, setFrames] = useState([]);
      const [selectedId, setSelectedId] = useState(null);
      const [error, setError] = useState(null);

      function parseText(text) {
        const out = [];
        const lines = text.split(/\\r?\\n/);

        const regexes = [
          /^(?<ts>\\d{1,4}[\\-:\\/\\s\\d\\.T]*?)\\s+(?<id>0x[0-9a-fA-F]+|\\d+)[:]?\\s*(?<rest>.*)$/,
          /^(?<id>0x[0-9a-fA-F]+|\\d+)\\s+(?<rest>(?:[A-Fa-f0-9]{2}\\s*)+)$/,
          /^(?<ts>\\d+[:\\d\\-\\.T ]+)\\s+(?<rest>.*)$/,
          /^(?<rest>(?:[A-Fa-f0-9]{2}\\s*)+)$/,
        ];

        for (let i = 0; i < lines.length; i++) {
          const raw = lines[i].trim();
          if (!raw) continue;
          let parsed = null;

          for (const re of regexes) {
            const m = raw.match(re);
            if (m && m.groups) {
              parsed = { groups: m.groups };
              break;
            }
          }

          if (!parsed) {
            const idMatch = raw.match(/(0x[0-9a-fA-F]+|\\b\\d{1,4}\\b)/);
            const bytesMatch = raw.match(/([A-Fa-f0-9]{2}(?:\\s+[A-Fa-f0-9]{2})+)/);
            const tsMatch = raw.match(/\\d{4}-\\d{2}-\\d{2}.*|\\d+\\.\\d+/);
            parsed = { groups: { id: idMatch ? idMatch[1] : null, rest: bytesMatch ? bytesMatch[1] : '', ts: tsMatch ? tsMatch[0] : null } };
          }

          const g = parsed.groups;
          const idRaw = g.id || null;
          const id = idRaw ? (idRaw.toLowerCase().startsWith('0x') ? idRaw.toLowerCase() : String(parseInt(idRaw, 10))) : null;

          const bytes = (g.rest || '')
            .trim()
            .split(/\\s+/)
            .filter((b) => /^[A-Fa-f0-9]{2}$/.test(b))
            .map((b) => b.toUpperCase());

          let ts = null;
          if (g.ts) {
            const maybeDate = new Date(g.ts);
            if (!isNaN(maybeDate)) ts = maybeDate.getTime();
            else {
              const sec = parseFloat(g.ts);
              if (!isNaN(sec)) ts = Math.round(sec * 1000);
            }
          }

          out.push({ raw, id, bytes, ts, index: i });
        }

        const hasTs = out.some((f) => f.ts !== null && f.ts !== undefined);
        if (!hasTs) {
          for (let i = 0; i < out.length; i++) out[i].ts = i * 1000;
        } else {
          let lastTs = out.find((f) => f.ts != null)?.ts ?? 0;
          for (let i = 0; i < out.length; i++) {
            if (out[i].ts == null) {
              lastTs += 1;
              out[i].ts = lastTs;
            } else lastTs = out[i].ts;
          }
        }

        return out;
      }

      function handleFileInput(e) {
        setError(null);
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
          try {
            const text = ev.target.result;
            const parsed = parseText(text);
            setFrames(parsed);
            const firstId = parsed.find((p) => p.id)?.id ?? null;
            setSelectedId(firstId);
          } catch (err) {
            console.error(err);
            setError('Failed to parse file');
          }
        };
        reader.readAsText(file);
      }

      const ids = useMemo(() => {
        const map = new Map();
        frames.forEach((f) => {
          const key = f.id ?? '(no-id)';
          if (!map.has(key)) map.set(key, []);
          map.get(key).push(f);
        });
        return Array.from(map.entries()).map(([id, arr]) => ({ id, count: arr.length, frames: arr }));
      }, [frames]);

      const chartData = useMemo(() => {
        if (!selectedId) return [];
        const list = frames.filter((f) => (f.id ?? '(no-id)') === selectedId);
        if (!list.length) return [];
        const buckets = new Map();
        list.forEach((f) => {
          const s = Math.floor(f.ts / 1000);
          buckets.set(s, (buckets.get(s) || 0) + 1);
        });
        const sorted = Array.from(buckets.entries()).sort((a, b) => a[0] - b[0]);
        return sorted.map(([s, c]) => ({ time: new Date(s * 1000).toISOString(), count: c }));
      }, [frames, selectedId]);

      return (
        <div>
          <h1 className="text-2xl font-bold mb-4">CAN Log Viewer — single file</h1>

          <div className="mb-4 flex gap-4 items-center">
            <label className="cursor-pointer px-4 py-2 bg-slate-800 text-white rounded">
              Choose .txt file
              <input type="file" accept=".txt,.log,.csv" className="hidden" onChange={handleFileInput} />
            </label>
            <div className="text-sm text-slate-600">Pick your CAN log text file. The parser tries common formats (timestamp, ID, payload bytes).</div>
          </div>

          {error && <div className="text-red-600">{error}</div>}

          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            <div className="md:col-span-1">
              <div className="bg-white border rounded p-3 shadow-sm">
                <h2 className="font-semibold">Found CAN IDs</h2>
                <div className="mt-2">
                  {ids.length === 0 && <div className="text-sm text-slate-500">No frames parsed yet.</div>}
                  <ul className="divide-y">
                    {ids.map((it) => (
                      <li key={it.id} className={\`\${selectedId === it.id ? 'bg-slate-100' : ''} py-2 flex justify-between items-center\`}>
                        <button className="text-left" onClick={() => setSelectedId(it.id)}>
                          <div className="font-mono">{it.id}</div>
                          <div className="text-xs text-slate-500">{it.count} frames</div>
                        </button>
                        <button className="text-xs px-2 py-1 border rounded" onClick={() => {
                          const sample = it.frames.slice(0,5).map(f=>f.raw).join('\\n');
                          navigator.clipboard?.writeText(sample);
                          alert('Copied sample lines for ID ' + it.id);
                        }}>Copy sample</button>
                      </li>
                    ))}
                  </ul>
                </div>
              </div>
            </div>

            <div className="md:col-span-2">
              <div className="bg-white border rounded p-3 shadow-sm">
                <h2 className="font-semibold">Chart / Messages over time</h2>
                <div style={{ height: 300 }} className="mt-2">
                  {chartData.length === 0 ? (
                    <div className="text-sm text-slate-500">Select an ID to see message frequency over time.</div>
                  ) : (
                    <ResponsiveContainer width="100%" height={300}>
                      <LineChart data={chartData}>
                        <CartesianGrid strokeDasharray="3 3" />
                        <XAxis dataKey="time" tickFormatter={(v)=>new Date(v).toLocaleTimeString()} />
                        <YAxis allowDecimals={false} />
                        <Tooltip labelFormatter={(v)=>new Date(v).toLocaleString()} />
                        <Line type="monotone" dataKey="count" stroke="#3b82f6" strokeWidth={2} dot={false} />
                      </LineChart>
                    </ResponsiveContainer>
                  )}
                </div>

                <h3 className="mt-4 font-semibold">Frames (most recent 200)</h3>
                <div className="overflow-auto max-h-72 mt-2">
                  <table className="w-full text-left text-sm">
                    <thead className="sticky top-0 bg-white">
                      <tr>
                        <th className="p-2">Time</th>
                        <th className="p-2">ID</th>
                        <th className="p-2">Bytes</th>
                        <th className="p-2">Raw</th>
                      </tr>
                    </thead>
                    <tbody>
                      {frames.slice().reverse().slice(0,200).map((f, idx) => (
                        <tr key={idx} className={\`\${(selectedId === (f.id ?? '(no-id)')) ? 'bg-slate-50' : ''}\`}>
                          <td className="p-2 align-top font-mono text-xs">{new Date(f.ts).toISOString()}</td>
                          <td className="p-2 align-top font-mono">{f.id ?? '(no-id)'}</td>
                          <td className="p-2 align-top font-mono text-xs">{f.bytes.join(' ')}</td>
                          <td className="p-2 align-top text-xs">{f.raw}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>

              </div>
            </div>
          </div>

          <div className="mt-6 text-sm text-slate-600">
            Notes: This is a single HTML file. No install needed. If you need extra features (DBC decoding, value plots per byte, CSV export, filters), tell me what exactly to add.
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<CANLogViewer />);
  </script>
</body>
</html>
