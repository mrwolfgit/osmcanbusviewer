<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>OSM CAN Bus Viewer (No-React)</title>
  <!-- Tailwind for styling -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Chart.js for the line chart -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
</head>
<body class="bg-slate-50">
  <div class="p-6 max-w-6xl mx-auto">
    <h1 class="text-2xl font-bold mb-4">OSM CAN Bus Viewer</h1>

    <div class="mb-4 flex flex-col sm:flex-row gap-4 items-start sm:items-center">
      <label class="cursor-pointer px-4 py-2 bg-slate-800 text-white rounded">
        Choose .txt/.log/.csv
        <input id="fileInput" type="file" accept=".txt,.log,.csv" class="hidden" />
      </label>
      <div class="text-sm text-slate-600">
        Upload a CAN log text file (timestamp + ID + payload bytes). Common formats are detected automatically.
      </div>
      <div id="errorBox" class="text-sm text-red-600 hidden"></div>
    </div>

    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
      <!-- IDs list -->
      <div class="md:col-span-1">
        <div class="bg-white border rounded p-3 shadow-sm">
          <h2 class="font-semibold">Found CAN IDs</h2>
          <div id="idsList" class="mt-2 text-sm">
            <div class="text-slate-500">No frames parsed yet.</div>
          </div>
        </div>
      </div>

      <!-- Chart + Table -->
      <div class="md:col-span-2">
        <div class="bg-white border rounded p-3 shadow-sm">
          <h2 class="font-semibold">Message Frequency</h2>
          <div class="mt-2" style="height:300px">
            <canvas id="freqChart" height="300"></canvas>
          </div>

          <h3 class="mt-4 font-semibold">Recent Frames (max 200)</h3>
          <div class="overflow-auto max-h-72 mt-2">
            <table class="w-full text-left text-sm">
              <thead class="sticky top-0 bg-white">
              <tr>
                <th class="p-2">Time</th>
                <th class="p-2">ID</th>
                <th class="p-2">Bytes</th>
                <th class="p-2">Raw</th>
              </tr>
              </thead>
              <tbody id="framesTbody"></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <p class="mt-6 text-sm text-slate-500">
      Tip: Click an ID on the left to update the chart and table. Use the “Copy” button to copy a few sample lines for that ID.
    </p>
  </div>

  <script>
    // ---------- State ----------
    let ALL_FRAMES = [];         // { raw, id, bytes[], ts, index }
    let GROUPS = [];             // [{ id, count, frames }]
    let SELECTED_ID = null;
    let chartInstance = null;

    // ---------- Utils ----------
    const $ = (sel) => document.querySelector(sel);
    const fmtIso = (ms) => new Date(ms).toISOString();

    function showError(msg) {
      const box = $('#errorBox');
      box.textContent = msg;
      box.classList.toggle('hidden', !msg);
    }

    // Robust parser for many CAN log text formats
    function parseText(text) {
      const out = [];
      const lines = text.split(/\r?\n/);

      const regexes = [
        // timestamp + id + rest
        /^(?<ts>\d{1,4}[-:\/\s\d\.T]*?)\s+(?<id>0x[0-9a-fA-F]+|\d+)[:\s]*?(?<rest>.*)$/i,
        // id + bytes
        /^(?<id>0x[0-9a-fA-F]+|\d+)\s+(?<rest>(?:[A-Fa-f0-9]{2}\s*)+)$/i,
        // timestamp + rest
        /^(?<ts>\d+[:\d\-\.T ]+)\s+(?<rest>.*)$/i,
        // only bytes
        /^(?<rest>(?:[A-Fa-f0-9]{2}\s*)+)$/i
      ];

      for (let i = 0; i < lines.length; i++) {
        const raw = lines[i].trim();
        if (!raw) continue;
        let parsed = null;

        for (const re of regexes) {
          const m = raw.match(re);
          if (m && m.groups) { parsed = { groups: m.groups }; break; }
        }

        if (!parsed) {
          // Fallback hunt
          const idMatch = raw.match(/(0x[0-9a-fA-F]+|\b\d{1,4}\b)/);
          const bytesMatch = raw.match(/([A-Fa-f0-9]{2}(?:\s+[A-Fa-f0-9]{2})+)/);
          const tsMatch = raw.match(/\d{4}-\d{2}-\d{2}.*|\d+\.\d+/);
          parsed = { groups: { id: idMatch ? idMatch[1] : null, rest: bytesMatch ? bytesMatch[1] : '', ts: tsMatch ? tsMatch[0] : null } };
        }

        const g = parsed.groups;
        const idRaw = g.id || null;
        const id = idRaw ? (idRaw.toLowerCase().startsWith('0x') ? idRaw.toLowerCase() : String(parseInt(idRaw, 10))) : null;

        const bytes = (g.rest || '')
          .trim()
          .split(/\s+/)
          .filter(b => /^[A-Fa-f0-9]{2}$/.test(b))
          .map(b => b.toUpperCase());

        let ts = null;
        if (g.ts) {
          const d = new Date(g.ts);
          if (!isNaN(d)) ts = d.getTime();
          else {
            const sec = parseFloat(g.ts);
            if (!isNaN(sec)) ts = Math.round(sec * 1000);
          }
        }
        out.push({ raw, id, bytes, ts, index: i });
      }

      // Timestamps: fill/interpolate if missing
      const hasTs = out.some(f => f.ts !== null && f.ts !== undefined);
      if (!hasTs) {
        for (let i = 0; i < out.length; i++) out[i].ts = i * 1000;
      } else {
        let last = out.find(f => f.ts != null)?.ts ?? 0;
        for (let i = 0; i < out.length; i++) {
          if (out[i].ts == null) { last += 1; out[i].ts = last; }
          else last = out[i].ts;
        }
      }

      return out;
    }

    function groupById(frames) {
      const map = new Map();
      frames.forEach(f => {
        const key = f.id ?? '(no-id)';
        if (!map.has(key)) map.set(key, []);
        map.get(key).push(f);
      });
      return Array.from(map.entries()).map(([id, arr]) => ({ id, count: arr.length, frames: arr }));
    }

    function buildIdsList() {
      const host = $('#idsList');
      host.innerHTML = '';
      if (GROUPS.length === 0) {
        host.innerHTML = '<div class="text-slate-500">No frames parsed yet.</div>';
        return;
      }

      const ul = document.createElement('ul');
      ul.className = 'divide-y';
      GROUPS.forEach((it) => {
        const li = document.createElement('li');
        li.className = 'py-2 flex justify-between items-center ' + (SELECTED_ID === it.id ? 'bg-slate-100' : '');

        const btn = document.createElement('button');
        btn.className = 'text-left';
        btn.onclick = () => { SELECTED_ID = it.id; updateChartAndTable(); buildIdsList(); };
        btn.innerHTML = `
          <div class="font-mono">${it.id}</div>
          <div class="text-xs text-slate-500">${it.count} frames</div>
        `;

        const copyBtn = document.createElement('button');
        copyBtn.className = 'text-xs px-2 py-1 border rounded';
        copyBtn.textContent = 'Copy';
        copyBtn.onclick = () => {
          const sample = it.frames.slice(0, 5).map(f => f.raw).join('\n');
          navigator.clipboard?.writeText(sample);
          alert('Copied sample lines for ID ' + it.id);
        };

        li.appendChild(btn);
        li.appendChild(copyBtn);
        ul.appendChild(li);
      });
      host.appendChild(ul);
    }

    function buildChart(labels, values) {
      const ctx = document.getElementById('freqChart');
      if (chartInstance) { chartInstance.destroy(); }
      chartInstance = new Chart(ctx, {
        type: 'line',
        data: {
          labels,
          datasets: [{
            label: 'Messages / sec',
            data: values,
            borderWidth: 2,
            tension: 0.25,
            pointRadius: 0
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: { ticks: { callback: (v, i) => new Date(labels[i]).toLocaleTimeString() } },
            y: { beginAtZero: true, ticks: { precision: 0 } }
          },
          plugins: {
            tooltip: {
              callbacks: {
                title: (items) => new Date(items[0].label).toLocaleString()
              }
            },
            legend: { display: false }
          }
        }
      });
    }

    function updateChartAndTable() {
      const list = ALL_FRAMES.filter(f => (f.id ?? '(no-id)') === SELECTED_ID);
      // Chart buckets per second
      const buckets = new Map();
      list.forEach(f => {
        const s = Math.floor(f.ts / 1000);
        buckets.set(s, (buckets.get(s) || 0) + 1);
      });
      const sorted = Array.from(buckets.entries()).sort((a,b) => a[0]-b[0]);
      const labels = sorted.map(([s]) => new Date(s * 1000).toISOString());
      const values = sorted.map(([,c]) => c);
      buildChart(labels, values);

      // Table
      const tbody = $('#framesTbody');
      tbody.innerHTML = '';
      const recent = list.slice().reverse().slice(0, 200);
      recent.forEach((f) => {
        const tr = document.createElement('tr');
        if (SELECTED_ID === (f.id ?? '(no-id)')) tr.className = 'bg-slate-50';
        tr.innerHTML = `
          <td class="p-2 font-mono text-xs">${fmtIso(f.ts)}</td>
          <td class="p-2 font-mono">${f.id ?? '(no-id)'}</td>
          <td class="p-2 font-mono text-xs">${(f.bytes||[]).join(' ')}</td>
          <td class="p-2 text-xs">${f.raw}</td>
        `;
        tbody.appendChild(tr);
      });
    }

    // ---------- File handling ----------
    document.getElementById('fileInput').addEventListener('change', (e) => {
      showError('');
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        try {
          const text = ev.target.result;
          ALL_FRAMES = parseText(text);
          GROUPS = groupById(ALL_FRAMES);
          SELECTED_ID = GROUPS.find(g => g.id && g.id !== '(no-id)')?.id || GROUPS[0]?.id || null;
          buildIdsList();
          if (SELECTED_ID) updateChartAndTable();
        } catch (err) {
          console.error(err);
          showError('Failed to parse file.');
        }
      };
      reader.readAsText(file);
    });
  </script>
</body>
</html>
